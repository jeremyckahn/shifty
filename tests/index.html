<html>
<head>
<link href="qunit/qunit.css" rel="stylesheet" type="text/css" />
<head>
<body>

<h1 id="qunit-header"><a href="https://github.com/jeremyckahn/shifty">Shifty</a></h1>
 <h2 id="qunit-banner"></h2>
 <div id="qunit-testrunner-toolbar"></div>
 <h2 id="qunit-userAgent"></h2>
 <ol id="qunit-tests"></ol>
 <div id="qunit-fixture"></div>
<script src="qunit/qunit.js"></script>
<script>
  var mockTime = function () {
    return +(new Date());
  }
  ,SHIFTY_DEBUG_NOW = function () {
    return mockTime();
  };
  // Needed for `root` reference in uncompiled source files.
  window.root = this;
</script>
<script src="../src/shifty.core.js"></script>
<script src="../src/shifty.formulas.js"></script>
<script src="../src/shifty.interpolate.js"></script>
<script src="../src/shifty.token.js"></script>
<script src="../src/shifty.bezier.js"></script>

<script>
  (function () {
    var log = console.log;

    function forceInternalUpdate (tweenable) {
      timeoutHandler(tweenable, tweenable._timestamp, tweenable._duration,
      tweenable._currentState, tweenable._originalState,
      tweenable._targetState, tweenable._easing, tweenable._step, tweenable._scheduleFunction);
    }

    module('Tweenable.prototype.tween (longhand format)');

    test('Midpoints of a tween are correctly computed', function () {
      var tweenable = new Tweenable();
      mockTime = function () {return 0;};
      tweenable.tween({
        from: { x: 0 }
        ,to: { x: 100 }
        ,duration: 1000
      });

      equals(tweenable.get().x, 0, 'The tween starts at 0');
      mockTime = function () {return 500;};
      forceInternalUpdate(tweenable);
      equals(tweenable.get().x, 50,
          'The middle of the tween equates to .5 of the target value');
      mockTime = function () {return 1000;};
      forceInternalUpdate(tweenable);
      equals(tweenable.get().x, 100,
          'The end of the tween equates to 1.0 of the target value');
      mockTime = function () {return 100000;};
      forceInternalUpdate(tweenable);
      equals(tweenable.get().x, 100,
          'Anything after end of the tween equates to 1.0 of the target value');
    });


    module('Tweenable.prototype.pause');

    test('pause() moves the end time of the tween', function () {
      var tweenable = new Tweenable();
      mockTime = function () {return 0;};
      tweenable.tween({
        from: { x: 0 },
        to: { x: 100 },
        duration: 1000
      });

      mockTime = function () {return 500;};
      forceInternalUpdate(tweenable);
      equals(tweenable.get().x, 50,
          'Pre-pause: The middle of the tween equates to .5 of the target value');
      tweenable.pause();
      mockTime = function () {return 2000;};
      tweenable.resume();
      forceInternalUpdate(tweenable);
      equals(tweenable.get().x, 50,
          'The tween has not changed in the time that it has been paused');
      mockTime = function () {return 2500;};
      forceInternalUpdate(tweenable);
      equals(tweenable.get().x, 100,
          'The tween ends at the modified end time');
    });


    module('Tweenable.prototype.stop');

    test('stop(undefined) leaves a tween where it was stopped', function () {
      var tweenable = new Tweenable();
      mockTime = function () {return 0;};
      tweenable.tween({
        from: { x: 0 },
        to: { x: 100 },
        duration: 1000
      });

      mockTime = function () {return 500;};
      forceInternalUpdate(tweenable);
      tweenable.stop();
      equals(tweenable.get().x, 50,
          'The tweened value did not go to the end, it was left at its last updated position');
      equals(tweenable._isTweening, false,
          'The internal state of the Tweenable indicates it is not running (updating)');
    });

    test('stop(true) skips a tween to the end', function () {
      var tweenable = new Tweenable();
      mockTime = function () {return 0;};
      tweenable.tween({
        from: { x: 0 },
        to: { x: 100 },
        duration: 1000
      });

      mockTime = function () {return 500;};
      forceInternalUpdate(tweenable);
      tweenable.stop(true);
      equals(tweenable.get().x, 100,
          'The tweened value jumps to the end');
    });

    module('Tweenable.prototype.setScheduleFunction');

    test('calling setScheduleFunction change the internal schedule function', function () {
        var mockScheduleFunctionCalls = [];
        function mockScheduleFunction(fn, delay) {
            mockScheduleFunctionCalls.push({fn:fn, delay: delay});
        }

        var tweenable = new Tweenable();
        tweenable.setScheduleFunction(mockScheduleFunction);
        mockTime = function () {return 0;};
        tweenable.tween({
            from: { x: 0 },
            to: { x: 100 },
            duration: 1000
        });

        mockTime = function () {return 500;};
        forceInternalUpdate(tweenable);
        tweenable.stop(true);

        ok(mockScheduleFunctionCalls.length,
                'The custom schedule function has been called');
        ok(typeof mockScheduleFunctionCalls[0].fn === 'function',
                'The first given parameter to the custom schedule function was a function');
        ok(typeof mockScheduleFunctionCalls[0].delay === 'number',
                'The second given parameter to the custom schedule function was a number');
    });

    module('interpolate');

    test('Static - Interpolate can compute the midpoint of two numbers',
        function () {

      var interpolated = Tweenable.interpolate({ x: 0 }, { x: 10 }, .5);

      equals(5, interpolated.x, 'Midpoint was computed');
    });

    test('Interpolate can compute the midpoint of two token strings',
        function () {

      var interpolated = Tweenable.interpolate({ color: '#000' }, { color: '#fff' }, .5);

      equals('rgb(127,127,127)', interpolated.color,
          'Midpoint color was computed');
    });


    module('Token');

    test('Can tween an RGB color', function () {
      var from = { color: 'rgb(0,128,255)' }
          ,to = { color: 'rgb(128,255,0)' };

      var interpolated = Tweenable.interpolate(from, to, 0);
      equals(interpolated.color, from.color,
          'The initial interpolated value is the same as the initial color');
      interpolated = Tweenable.interpolate(from, to, .5);
      equals(interpolated.color, 'rgb(64,191,127)',
          'The interpolated value at 50% is a 50/50 mixture of the start and end colors');
      interpolated = Tweenable.interpolate(from, to, 1);
      equals(interpolated.color, to.color,
          'The final interpolated value is the same as the target color');
    });

    test('Can tween an RGB color with a number in the tween', function () {
      var from = { color: 'rgb(0,128,255)', x: 0 }
          ,to =  { color: 'rgb(128,255,0)', x: 10 };

      var interpolated = Tweenable.interpolate(from, to, 0);
      equals(interpolated.color, from.color,
          'The initial interpolated value is the same as the initial color');
      interpolated = Tweenable.interpolate(from, to, .5);
      equals(interpolated.color, 'rgb(64,191,127)',
          'The interpolated color value at 50% is a 50/50 mixture of the start and end colors');
      equals(interpolated.x, 5,
          'The interpolated x value at 50% is the midpoint of the start and end x values');
      interpolated = Tweenable.interpolate(from, to, 1);
      equals(interpolated.color, to.color,
          'The final interpolated value is the same as the target color');
    });

    test('Can Tween hex color values', function () {
      var from = { color: '#ff00ff' }
          ,to =  { color: '#00ff00' };

      var interpolated = Tweenable.interpolate(from, to, 0);
      equals(interpolated.color, 'rgb(255,0,255)',
          'The initial interpolated value is the rgb equivalent as the initial color');
      interpolated = Tweenable.interpolate(from, to, .5);
      equals(interpolated.color, 'rgb(127,127,127)',
          'The interpolated value at 50% is a 50/50 mixture of the start and end colors');
      interpolated = Tweenable.interpolate(from, to, 1);
      equals(interpolated.color, 'rgb(0,255,0)',
          'The final interpolated value is the rgb equivalent as the target color');
    });

    test('Can tween multiple RGB color tokens', function () {
      var from = { color: 'rgb(0,128,255) rgb(255,0,255)' }
          ,to =  { color: 'rgb(128,255,0) rgb(0,255,0)' };

      var interpolated = Tweenable.interpolate(from, to, 0);
      equals(interpolated.color, from.color,
          'The initial interpolated value is the same as the initial color');
      interpolated = Tweenable.interpolate(from, to, .5);
      equals(interpolated.color, 'rgb(64,191,127) rgb(127,127,127)',
          'The interpolated value at 50% is a 50/50 mixture of the start and end colors');
      interpolated = Tweenable.interpolate(from, to, 1);
      equals(interpolated.color, to.color,
          'The final interpolated value is the same as the target color');
    });

    test('Each token chunk can have it\'s own easing curve', function () {
      var from = { color: 'rgb(0,0,0)' }
          ,to =  { color: 'rgb(255,255,255)' }
          ,easing = 'linear easeInQuad easeInCubic';

      var interpolated = Tweenable.interpolate(from, to, .5, easing);
      var interpolatedR = parseInt(Tweenable.interpolate(
                            {r:0}, {r:255}, .5, 'linear').r, 10);
      var interpolatedG = parseInt(Tweenable.interpolate(
                            {g:0}, {g:255}, .5, 'easeInQuad').g, 10);
      var interpolatedB = parseInt(Tweenable.interpolate(
                            {b:0}, {b:255}, .5, 'easeInCubic').b, 10);
      var targetString = 'rgb(' + interpolatedR + ',' + interpolatedG + ','
          + interpolatedB + ')';

      equals(interpolated.color, targetString,
          'The computed tween value respects the easing strings supplied and their cardinality');
    });

    test('Missing token eases inherit from the last easing listed', function () {
      var from = { color: 'rgb(0,0,0)' }
          ,to =  { color: 'rgb(255,255,255)' }
          ,easing = 'linear easeInQuad';

      var interpolated = Tweenable.interpolate(from, to, .5, easing);
      var interpolatedR = parseInt(Tweenable.interpolate(
                            {r:0}, {r:255}, .5, 'linear').r, 10);
      var interpolatedG = parseInt(Tweenable.interpolate(
                            {g:0}, {g:255}, .5, 'easeInQuad').g, 10);
      var interpolatedB = parseInt(Tweenable.interpolate(
                            {b:0}, {b:255}, .5, 'easeInQuad').b, 10);
      var targetString = 'rgb(' + interpolatedR + ',' + interpolatedG + ','
          + interpolatedB + ')';

      equals(interpolated.color, targetString,
          'The computed tween value inherits the last tween listed if there is a cardinality mismatch');
    });

    test('Can tween a negative value token to a positive value', function () {
      var from = { transform: 'translateX(-50)' }
          ,to =  { transform: 'translateX(50)' }
          ,easing = 'linear';

      var interpolated = Tweenable.interpolate(from, to, 0);
      equals(interpolated.transform, 'translateX(-50)',
          'The initial interpolated value is the same as the initial transform');
      interpolated = Tweenable.interpolate(from, to, .5);
      equals(interpolated.transform, 'translateX(0)',
          'The interpolated value at 50% is at the midpoint of the start and end translations');
      interpolated = Tweenable.interpolate(from, to, 1);
      equals(interpolated.transform, 'translateX(50)',
          'The final interpolated value is the same as the target transform');
    });

    test('Midpoints of a color tween are correctly computed', function () {
      var tweenable = new Tweenable();
      mockTime = function () {return 0;};
      tweenable.tween({
        from: { color: 'rgb(0,0,0)' }
        ,to: { color: 'rgb(10,10,10)' }
        ,duration: 1000
      });

      equals(tweenable.get().color, 'rgb(0,0,0)',
          'The tween starts at the initial rgb value');
      mockTime = function () {return 500;};
      forceInternalUpdate(tweenable);
      equals(tweenable.get().color, 'rgb(5,5,5)',
          'The 50% midpoint of a tween has been computed');
      mockTime = function () {return 1000;};
      forceInternalUpdate(tweenable);
      equals(tweenable.get().color, 'rgb(10,10,10)',
          'The tween ends at the final rgb value');
      mockTime = function () {return 100000;};
    });

    test('Can interpolate two number strings that have no non-number token structure',
        function () {
        var from = { x: '2' };
        var to = { x: '3' };
        var interpolated = Tweenable.interpolate(from, to, 0.5);

        equals(interpolated.x, '2.5',
            'Token-less strings were successfully interpolated');
    });

    test('Can tween CSS value pairs', function () {
      var from = { x: '0px 0px' };
      var to = { x: '100px 100px' };

      var interpolated = Tweenable.interpolate(from, to, .5);
      equals(interpolated.x, '50px 50px', 'The string was interpolated correctly');
    });


    module('Bezier extension');

    test('Can create a linear Bezier easing curve', function () {
      Tweenable.setBezierFunction('bezier-linear', 0.250, 0.250, 0.750, 0.750);

      equals(
        Tweenable.interpolate({x: 0}, {x: 10}, 0.25, 'linear').x.toFixed(1),
        Tweenable.interpolate({x: 0}, {x: 10}, 0.25, 'bezier-linear').x.toFixed(1),
        'linear and dynamic bezier-linear are reasonably equivalent at 0.25');
      equals(
        Tweenable.interpolate({x: 0}, {x: 10}, 0.5, 'linear').x.toFixed(1),
        Tweenable.interpolate({x: 0}, {x: 10}, 0.5, 'bezier-linear').x.toFixed(1),
        'linear and dynamic bezier-linear are reasonably equivalent at 0.5');
      equals(
        Tweenable.interpolate({x: 0}, {x: 10}, 0.75, 'linear').x.toFixed(1),
        Tweenable.interpolate({x: 0}, {x: 10}, 0.75, 'bezier-linear').x.toFixed(1),
        'linear and dynamic bezier-linear are reasonably equivalent at 0.75');
    });

    test('Can create a "stretched" linear Bezier easing curve', function () {
      Tweenable.setBezierFunction('bezier-stretched-linear', 0, 0, 1, 1);

      equals(
        Tweenable.interpolate({x: 0}, {x: 10}, 0.25, 'linear').x.toFixed(1),
        Tweenable.interpolate({x: 0}, {x: 10}, 0.25, 'bezier-stretched-linear').x.toFixed(1),
        'linear and dynamic bezier-stretched-linear are reasonably equivalent at 0.25');
      equals(
        Tweenable.interpolate({x: 0}, {x: 10}, 0.5, 'linear').x.toFixed(1),
        Tweenable.interpolate({x: 0}, {x: 10}, 0.5, 'bezier-stretched-linear').x.toFixed(1),
        'linear and dynamic bezier-stretched-linear are reasonably equivalent at 0.5');
      equals(
        Tweenable.interpolate({x: 0}, {x: 10}, 0.75, 'linear').x.toFixed(1),
        Tweenable.interpolate({x: 0}, {x: 10}, 0.75, 'bezier-stretched-linear').x.toFixed(1),
        'linear and dynamic bezier-stretched-linear are reasonably equivalent at 0.75');
    });

    test('Can remove a Bezier easing curve', function () {
      Tweenable.setBezierFunction('bezier-linear', 0, 0, 1, 1);
      Tweenable.unsetBezierFunction('bezier-linear');
      ok(!Tweenable.prototype['bezier-linear'],
        '"bezier-linear" was deleted');
    });

    test('Bezier handle positions are stored on a custom easing function',
        function () {

      var easingFunction =
          Tweenable.setBezierFunction('decoration-test', .2, .4, .6, .8);

      equals(easingFunction.x1, .2, 'Easing function was decorated with x1');
      equals(easingFunction.y1, .4, 'Easing function was decorated with y1');
      equals(easingFunction.x2, .6, 'Easing function was decorated with x2');
      equals(easingFunction.y2, .8, 'Easing function was decorated with y2');
    });

  } ());
</script>

</body>
</html>
